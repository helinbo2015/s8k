---
layout: post
title: 用户自定义的logf风格代码，go vet工具报错
category: golang
---

##### 1. go vet错误现象  
最近用到公司通用的日志库(应该是2年前写的)，当通过CI跑go tool vet检查时，下面的代码报了错误(估计2年前的代码应该没有跑go vet)。

```Go
func (l *logger) logf(loglevel int, err error, format string, args ...interface{}) {
        logmsg := fmt.Sprintf(format, args...)
        l.log(loglevel, logmsg, err)
}

func (l *logger) Debugf(format string, args ...interface{}) {
        l.logf(1, nil, format, args...)    // go vet error
}
```

<!--description-->
报的错误: `constant 1 not a string in call to logf`， 但是上面代码中，`logf()`函数的第一个参数明明要求就是`int`类型，go vet却认为`logf()`需要的是`string`类型

##### 2. 错误原因  
直接说吧，就是`go vet`的问题。这个工具默认如果用户定义了下面的函数，那么也要求定义函数和库函数一样格式。比如说第一个参数就是`string`类型。

```Go
var printfList = map[string]int{
    "errorf":  0,
    "fatalf":  0,
    "fprintf": 1,
    "logf":    0,
    "panicf":  0,
    "printf":  0,
    "sprintf": 0,
}
```

具体可以参照: [cmd/vet: go vet incorrectly warns of "no formatting directive in Errorf call" for non core methods with same name](https://github.com/golang/go/issues/12294)  

##### 3. 解决办法  
目前办法有下面两个:  
1. 升级go的版本到1.7以上，上面的问题在1.7中已经解决了。  
2. 如果不方便升级版本，只能换一个函数名了。比如说下面这样。  

```Go
func (l *logger) Debugf(format string, args ...interface{}) {
        log := l.logf    // confuse `go vet` to not check this `logf` call.
        log(1, nil, format, args...)
}
```

参考链接:  

- [go vet says Errorf calls are all wrong, "constant 1 not a string in call to Errorf"](https://github.com/grpc/grpc-go/issues/90)  
- [cmd/vet: Always errors if printf-style function from an imported package is used](https://github.com/golang/go/issues/14754)  
- [cmd/vet: go vet incorrectly warns of "no formatting directive in Errorf call" for non core methods with same name](https://github.com/golang/go/issues/12294)  
